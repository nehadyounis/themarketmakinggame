#pragma once

#include "types.h"
#include <map>
#include <list>
#include <memory>
#include <vector>

namespace mmg {

struct Order {
    OrderId id;
    UserId user_id;
    InstrumentId instrument_id;
    Side side;
    Price price;
    Quantity quantity;
    Quantity filled_quantity;
    OrderStatus status;
    TimeInForce tif;
    bool post_only;
    Timestamp timestamp;
    
    Order() : id(0), user_id(0), instrument_id(0), side(Side::BUY),
              price(0), quantity(0), filled_quantity(0), 
              status(OrderStatus::PENDING), tif(TimeInForce::GFD),
              post_only(false) {}
};

class OrderBook {
public:
    OrderBook(InstrumentId instrument_id);
    
    // Returns fills generated by matching
    std::vector<Fill> add_order(const std::shared_ptr<Order>& order) noexcept;
    
    bool cancel_order(OrderId order_id) noexcept;
    
    // Get market snapshot (top N levels)
    MarketSnapshot get_snapshot(size_t depth = 10) const noexcept;
    
    // Get best bid/ask
    Price get_best_bid() const noexcept;
    Price get_best_ask() const noexcept;
    
    // Get last trade price
    Price get_last_price() const noexcept { return last_price_; }
    
private:
    InstrumentId instrument_id_;
    Price last_price_;
    
    // Price level -> list of orders (FIFO)
    std::map<Price, std::list<std::shared_ptr<Order>>, std::greater<Price>> bids_;  // Descending
    std::map<Price, std::list<std::shared_ptr<Order>>> asks_;  // Ascending
    
    // Quick lookup by order ID
    std::map<OrderId, std::shared_ptr<Order>> orders_;
    
    std::vector<Fill> match_order(std::shared_ptr<Order>& order) noexcept;
    void add_to_book(const std::shared_ptr<Order>& order) noexcept;
    Fill create_fill(const std::shared_ptr<Order>& aggressor, 
                     const std::shared_ptr<Order>& passive,
                     Price price, Quantity quantity) noexcept;
};

}  // namespace mmg

